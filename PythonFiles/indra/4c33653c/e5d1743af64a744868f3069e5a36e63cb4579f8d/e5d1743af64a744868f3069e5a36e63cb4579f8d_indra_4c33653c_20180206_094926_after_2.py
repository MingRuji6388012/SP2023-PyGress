"""
This module takes the TEES parse graph generated by parse_tees and converts it
into INDRA statements.

See publication:
Jari Bj√∂rne, Sofie Van Landeghem, Sampo Pyysalo, Tomoko Ohta, Filip Ginter, Yves Van de Peer, Sofia Ananiadou and Tapio Salakoski, PubMed-Scale Event Extraction for Post-Translational Modifications, Epigenetics and Protein Structural Relations. Proceedings of BioNLP 2012, pages 82-90, 2012.
"""

from __future__ import absolute_import, print_function, unicode_literals
from builtins import dict, str
from future.utils import python_2_unicode_compatible

from indra.statements import Phosphorylation
from indra.sources.tees.parse_tees import run_and_parse_tees

class TEESProcessor(object):
    """Converts the specified text into a series of INDRA statmenets.

    Only extracts a subset of INDRA statements. Currently supported
    statements are:
    * Phosphorylation

    Parameters
    ----------
    text: str
        Plain text from biomedical publications from which to extract
        INDRA statements.
    tees_path: str
        Path to the directory containing the TEES installation, in
        particular containing TEES' classify.py.
    python2_path: str
        Absolute path to a python 2 interpreter. This is needed to run
        TEES because TEES is only compatabile with python 2. If None then
        searches for an executable named python2 in the path.

    Attributes
    ----------
    statements: list[indra.statements.Statement]
        A list of INDRA statements extracted from the provided text via TEES
    """

    def __init__(self, text, tees_path, python2_path):
        # Run TEES and parse into networkx graph
        self.G = run_and_parse_tees(text, tees_path, python2_path)

        # Extract statements from the TEES graph
        self.statements = []
        self.statements.extend(self.make_phosphorylation_statements())

    def node_has_edge_with_label(self, node_name, edge_label):
        """Looks for an edge from node_name to some other node with the specified
        label. Returns the node to which this edge points if it exists, or None
        if it doesn't.

        Parameters
        ----------
        G:
            The graph object
        node_name:
            Node that the edge starts at
        edge_label:
            The text in the relation property of the edge
        """
        G = self.G
        for to in G.edge[node_name].keys():
            relation_name = G.edge[node_name][to]['relation']
            if relation_name == edge_label:
                return to
        return None

    def general_node_label(self, node):
        """Used for debugging - gives a short text description of a
        graph node."""
        G = self.G
        if G.node[node]['is_event']:
            return 'event type=' + G.node[node]['type']
        else:
            return 'entity text=' + G.node[node]['text']

    def print_parent_and_children_info(self, node):
        """Used for debugging - prints a short description of a a node, its
        children, its parents, and its parents' children."""
        G = self.G
        parents = G.predecessors(node)
        children = G.successors(node)

        print(general_node_label(G, node))
        tabs = '\t' 
        for parent in parents:
            relation = G.edge[parent][node]['relation']
            print(tabs + 'Parent (%s): %s' % (relation, general_node_label(G, parent)))
            for cop in G.successors(parent):
                if cop != node:
                    relation = G.edge[parent][cop]['relation']
                    print(tabs + 'Child of parent (%s): %s' % (relation, general_node_label(G, cop)))
        for child in children:
            relation = G.edge[node][child]['relation']
            print(tabs + 'Child (%s): (%s)' % (relation, general_node_label(G, child)))

    def find_event_parent_with_event_child(self, parent_name, child_name):
        """Finds all event nodes (is_event node attribute is True) that are
        of the type parent_name, that have a child event node with the type
        child_name."""
        G = self.G
        matches = []
        for n in G.node.keys():
            if G.node[n]['is_event'] and G.node[n]['type'] == parent_name:
                children = G.successors(n)
                for child in children:
                    if G.node[child]['is_event'] and G.node[child]['type'] == child_name:
                        matches.append((n, child))
                        break
        return list(set(matches))

    def get_entity_text_for_relation(self, node, relation):
        """Looks for an edge from node to some other node, such that the edge is
        annotated with the given relation. If there exists such an edge, and the
        node at the other edge is an entity, return that entity's text.
        Otherwise, returns None."""
        G = self.G
        for to in G.edge[node]:
            to_relation = G.edge[node][to]['relation']
            if to_relation == relation and not G.node[to]['is_event']:
                return G.node[to]['text']
        return None

    def make_phosphorylation_statements(self):
        """Looks for phosphorylation events in the graph and extracts them into
        INDRA statements.

        In particular, looks for a Positive_regulation event node with a child
        Phosphorylation event node.

        If Positive_regulation has an outgoing Cause edge, that's the subject
        If Phosphorylation has an outgoing Theme edge, that's the object
        If Phosphorylation has an outgoing Site edge, that's the site
        """
        G = self.G
        statements = []

        pwcs = self.find_event_parent_with_event_child('Positive_regulation',
                'Phosphorylation')
        for pair in pwcs:
            (pos_reg, phos) = pair
            cause = self.get_entity_text_for_relation(pos_reg, 'Cause')
            theme = self.get_entity_text_for_relation(phos, 'Theme')

            site = self.get_entity_text_for_relation(phos, 'Site')

            if theme is not None:
                statements.append( Phosphorylation(cause, theme, site) )
        return statements
            
if __name__ == '__main__':
    text = ''
    with codecs.open('abstracts_100.txt', 'r', encoding='utf-8') as f:
        text = text + f.read()

    tees_path = '/Users/daniel/Downloads/jbjorne-TEES-1125ab0'
    good_sentence = 'Raf increases the phosphorylation of BRAF.'
    weird_sentence = 'Serine 446 is constituitively phosphorylated in BRAF.'
    s = 'Our data demonstrated that Abl and Arg were activated downstream of chemokine receptors and mediated the chemokine-induced tyrosine phosphorylation of human enhancer of filamentation 1 (HEF1), an adaptor protein that is required for the activity of the guanosine triphosphatase Rap1, which mediates cell adhesion and migration.'
    events = run_and_parse_tees(tees_path, text)

    subgraph_nodes = set()
    for node in events.node:
        if events.node[node]['is_event'] and events.node[node]['type'] == 'Phosphorylation':
            subgraph_nodes.add(node)
            subgraph_nodes.update(dag.ancestors(events, node))
            subgraph_nodes.update(dag.descendants(events, node))
    print('Subgraph size: %d' % len(subgraph_nodes))
    print('Subgraph nodes: ', subgraph_nodes)
    tees_parse_networkx_to_dot(events, 'moo.dot', subgraph_nodes)

    statements = make_phosphorylation_statements(events)
    for s in statements:
        print(s)

