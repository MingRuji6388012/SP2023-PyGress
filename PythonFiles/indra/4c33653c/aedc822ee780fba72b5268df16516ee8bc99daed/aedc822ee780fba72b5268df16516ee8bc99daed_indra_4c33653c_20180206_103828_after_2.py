"""
This module takes the TEES parse graph generated by parse_tees and converts it
into INDRA statements.

See publication:
Jari Bj√∂rne, Sofie Van Landeghem, Sampo Pyysalo, Tomoko Ohta, Filip Ginter, Yves Van de Peer, Sofia Ananiadou and Tapio Salakoski, PubMed-Scale Event Extraction for Post-Translational Modifications, Epigenetics and Protein Structural Relations. Proceedings of BioNLP 2012, pages 82-90, 2012.
"""

from __future__ import absolute_import, print_function, unicode_literals
from builtins import dict, str
from future.utils import python_2_unicode_compatible

from indra.statements import Phosphorylation, Complex
from indra.sources.tees.parse_tees import run_and_parse_tees

class TEESProcessor(object):
    """Converts the specified text into a series of INDRA statmenets.

    Only extracts a subset of INDRA statements. Currently supported
    statements are:
    * Phosphorylation

    Parameters
    ----------
    text: str
        Plain text from biomedical publications from which to extract
        INDRA statements.
    tees_path: str
        Path to the directory containing the TEES installation, in
        particular containing TEES' classify.py.
    python2_path: str
        Absolute path to a python 2 interpreter. This is needed to run
        TEES because TEES is only compatabile with python 2. If None then
        searches for an executable named python2 in the path.

    Attributes
    ----------
    statements: list[indra.statements.Statement]
        A list of INDRA statements extracted from the provided text via TEES
    """

    def __init__(self, text, tees_path, python2_path):
        # Run TEES and parse into networkx graph
        self.G = run_and_parse_tees(text, tees_path, python2_path)

        # Extract statements from the TEES graph
        self.statements = []
        self.statements.extend(self.process_phosphorylation_statements())
        self.statements.extend(self.process_binding_statements())

    def node_has_edge_with_label(self, node_name, edge_label):
        """Looks for an edge from node_name to some other node with the specified
        label. Returns the node to which this edge points if it exists, or None
        if it doesn't.

        Parameters
        ----------
        G:
            The graph object
        node_name:
            Node that the edge starts at
        edge_label:
            The text in the relation property of the edge
        """
        G = self.G
        for to in G.edge[node_name].keys():
            relation_name = G.edge[node_name][to]['relation']
            if relation_name == edge_label:
                return to
        return None

    def general_node_label(self, node):
        """Used for debugging - gives a short text description of a
        graph node."""
        G = self.G
        if G.node[node]['is_event']:
            return 'event type=' + G.node[node]['type']
        else:
            return 'entity text=' + G.node[node]['text']

    def print_parent_and_children_info(self, node):
        """Used for debugging - prints a short description of a a node, its
        children, its parents, and its parents' children."""
        G = self.G
        parents = G.predecessors(node)
        children = G.successors(node)

        print(general_node_label(G, node))
        tabs = '\t' 
        for parent in parents:
            relation = G.edge[parent][node]['relation']
            print(tabs + 'Parent (%s): %s' % (relation, general_node_label(G, parent)))
            for cop in G.successors(parent):
                if cop != node:
                    relation = G.edge[parent][cop]['relation']
                    print(tabs + 'Child of parent (%s): %s' % (relation, general_node_label(G, cop)))
        for child in children:
            relation = G.edge[node][child]['relation']
            print(tabs + 'Child (%s): (%s)' % (relation, general_node_label(G, child)))

    def find_event_parent_with_event_child(self, parent_name, child_name):
        """Finds all event nodes (is_event node attribute is True) that are
        of the type parent_name, that have a child event node with the type
        child_name."""
        G = self.G
        matches = []
        for n in G.node.keys():
            if G.node[n]['is_event'] and G.node[n]['type'] == parent_name:
                children = G.successors(n)
                for child in children:
                    if G.node[child]['is_event'] and G.node[child]['type'] == child_name:
                        matches.append((n, child))
                        break
        return list(set(matches))

    def find_event_with_outgoing_edges(self, event_name, desired_relations):
        """Gets a list of event nodes with the specified event_name and
        outgoing edges annotated with each of the specified relations.

        Parameters
        ----------
        event_name: str
            Look for event nodes with this name
        desired_relations: list[str]
            Look for event nodes with outgoing edges annotated with each of
            these relations

        Returns
        -------
        event_nodes: list[str]
            Event nodes that fit the desired criteria
        """

        G = self.G
        desired_relations = set(desired_relations)

        desired_event_nodes = []

        for node in G.node.keys():
            if G.node[node]['is_event'] and G.node[node]['type'] == event_name:
                has_relations = [G.edge[node][to]['relation'] for \
                        to in G.edge[node].keys()]
                has_relations = set(has_relations)
                # Did the outgoing edges from this node have all of the
                # desired relations?
                if desired_relations.issubset(has_relations):
                    desired_event_nodes.append(node)
        return desired_event_nodes

    def get_entity_text_for_relation(self, node, relation):
        """Looks for an edge from node to some other node, such that the edge is
        annotated with the given relation. If there exists such an edge, and the
        node at the other edge is an entity, return that entity's text.
        Otherwise, returns None."""
        G = self.G
        for to in G.edge[node]:
            to_relation = G.edge[node][to]['relation']
            if to_relation == relation and not G.node[to]['is_event']:
                return G.node[to]['text']
        return None

    def process_phosphorylation_statements(self):
        """Looks for Phosphorylation events in the graph and extracts them into
        INDRA statements.

        In particular, looks for a Positive_regulation event node with a child
        Phosphorylation event node.

        If Positive_regulation has an outgoing Cause edge, that's the subject
        If Phosphorylation has an outgoing Theme edge, that's the object
        If Phosphorylation has an outgoing Site edge, that's the site
        """
        G = self.G
        statements = []

        pwcs = self.find_event_parent_with_event_child('Positive_regulation',
                'Phosphorylation')
        for pair in pwcs:
            (pos_reg, phos) = pair
            cause = self.get_entity_text_for_relation(pos_reg, 'Cause')
            theme = self.get_entity_text_for_relation(phos, 'Theme')

            site = self.get_entity_text_for_relation(phos, 'Site')

            if theme is not None:
                statements.append( Phosphorylation(cause, theme, site) )
        return statements

    def process_binding_statements(self):
        """Looks for Binding events in the graph and extracts them into INDRA
        statements.

        In particular, looks for a Binding event node with outgoing edges
        with relations Theme and Theme2 - the entities these edges point to
        are the two constituents of the Complex INDRA statement.
        """
        G = self.G
        statements = []

        binding_nodes = self.find_event_with_outgoing_edges('Binding',
                ['Theme', 'Theme2'])

        for node in binding_nodes:
            theme1 = self.get_entity_text_for_relation(node, 'Theme')
            theme2 = self.get_entity_text_for_relation(node, 'Theme2')

            assert(theme1 is not None)
            assert(theme2 is not None)

            statements.append( Complex([theme1, theme2]) )
        return statements

