import types
import json

from .decorators import pipeline_functions, pipeline
from indra.tools.assemble_corpus import *
from indra.belief.wm_scorer import *
from indra.preassembler.hierarchy_manager import *
from indra.statements import get_statement_by_name


class AssemblyPipeline():
    def __init__(self, steps=None):
        self.steps = steps if steps else []

    @classmethod
    def from_json_file(cls, filename):
        with open(filename, 'r') as f:
            steps = json.load(f)
        ap = AssemblyPipeline(steps)
        return ap

    def run(self, statements):
        for step in self.steps:
            statements = self.run_function(step, statements)
        return statements

    def append(self, func, *args, **kwargs):
        if isinstance(func, types.FunctionType):
            pipeline(func)
            func_name = func.__name__
        elif isinstance(func, str):
            func_name = func
        else:
            raise TypeError('Should be a function object or a string')
        new_step = self.create_new_step(func_name, *args, **kwargs)
        self.steps.append(new_step)

    def insert(self, ix, func, *args, **kwargs):
        if isinstance(func, types.FunctionType):
            pipeline(func)
            func_name = func.__name__
        elif isinstance(func, str):
            func_name = func
        else:
            raise TypeError('Should be a function object or a string')
        new_step = self.create_new_step(func_name, *args, **kwargs)
        self.steps.insert(ix, new_step)

    def create_new_step(self, func_name, *args, **kwargs):
        assert self.get_function_from_name(func_name)
        new_step = {'function': func_name}
        if args:
            new_step['args'] = [jsonify_arg_input(arg) for arg in args]
        if kwargs:
            new_step['kwargs'] = {
                k: jsonify_arg_input(v) for (k, v) in kwargs.items()}
        return new_step

    def get_function_parameters(self, func_dict):
        func_name = func_dict['function']
        args = func_dict.get('args', [])
        kwargs = func_dict.get('kwargs', {})
        return func_name, args, kwargs

    def get_function_from_name(self, name):
        if name in pipeline_functions:
            return pipeline_functions[name]
        raise NotRegisteredFunctionError('%s is not registered' % name)

    def run_simple_function(self, func_name, *args, **kwargs):
        func = self.get_function_from_name(func_name)
        if 'statements' in kwargs:
            statements = kwargs['statements']
            del kwargs['statements']
            return func(statements, *args, **kwargs)
        return func(*args, **kwargs)

    def run_function(self, func_dict, statements=None):
        func_name, args, kwargs = self.get_function_parameters(func_dict)
        new_args = []
        new_kwargs = {}
        for arg in args:
            arg_value = self.get_argument_value(arg)
            new_args.append(arg_value)
        for k, v in kwargs.items():
            kwarg_value = self.get_argument_value(v)
            new_kwargs[k] = kwarg_value
        if statements:
            new_kwargs['statements'] = statements
        return self.run_simple_function(func_name, *new_args, **new_kwargs)

    def is_function(self, argument, keyword='function'):
        if not isinstance(argument, dict):
            return False
        if keyword not in argument:
            return False
        return True

    def get_argument_value(self, argument):
        if self.is_function(argument, 'function'):
            # Argument is a function
            if argument.get('no_run', False):
                value = self.get_function_from_name(argument['function'])
            # Argument is a result of a function
            else:
                value = self.run_function(argument)
        # Argument is a statement type
        elif self.is_function(argument, 'stmt_type'):
            value = get_statement_by_name(argument.get('stmt_type'))
        # Argument is a simple value (str, int, boolean, etc.)
        else:
            value = argument
        return value


class NotRegisteredFunctionError(Exception):
    pass


class RunnableArgument():
    """Class representing arguments generated by calling a function.

    RunnableArguments should be used as args or kwargs in AssemblyPipeline
    `append` and `insert` methods.

    Parameters
    ----------
    func : str or function
        A function or a name of a function to be called to generate argument
        value.
    """
    def __init__(self, func, *args, **kwargs):
        if isinstance(func, types.FunctionType):
            pipeline(func)
            self.func_name = func.__name__
        elif isinstance(func, str):
            self.func_name = func
        else:
            raise TypeError('Should be a function object or a string')
        self.args = args
        self.kwargs = kwargs

    def to_json(self):
        """Jsonify to standard AssemblyPipeline step format."""
        json_dict = {'function': self.func_name}
        new_args = []
        new_kwargs = {}
        for arg in self.args:
            new_args.append(jsonify_arg_input(arg))
        for k, v in self.kwargs.items():
            new_kwargs[k] = jsonify_arg_input(v)
        if new_args:
            json_dict['args'] = new_args
        if new_kwargs:
            json_dict['kwargs'] = new_kwargs
        return json_dict


def jsonify_arg_input(arg):
    """Jsonify user input (in AssemblyPipeline `append` and `insert` methods)
    into a standard step json."""
    if isinstance(arg, RunnableArgument):
        return arg.to_json()
    # If a function object or name of a function is provided, we assume it
    # does not have to be run (function itself is argument).
    if isinstance(arg, types.FunctionType):
        pipeline(arg)
        return {'function': arg.__name__, 'no_run': True}
    if isinstance(arg, str) and arg in pipeline_functions:
        return {'function': arg, 'no_run': True}
    # For some functions Statement type has to be argument
    if isinstance(arg, Statement):
        return {'stmt_type': arg.__name__}
    # Argument is a simple value and can be stored as provided
    return arg
